# Plano Teórico para o Orquestrador de Grafos

## Filosofia Orientadora

Construiremos um orquestrador com foco em **Controle Explícito**, **Simplicidade de Estado** e **Interatividade Nativa**. O objetivo é evitar a complexidade de abstrações de grafos genéricas, favorecendo uma implementação minimalista e transparente. A capacidade de um humano interagir com o fluxo não será uma funcionalidade adicionada, mas um pilar fundamental do design.

---

## Fase 1: Definição dos Fundamentos (A Constituição)

Estes são os conceitos imutáveis que governam todo o sistema.

### 1. O Estado: A Fonte Única da Verdade
*   **Conceito:** Existirá um único objeto de estado por execução de grafo. Este objeto é a memória viva e completa do agente naquele momento.
*   **Conteúdo:** Ele conterá todo o contexto necessário para a tomada de decisões, como o histórico de mensagens, resultados de ferramentas, entradas do usuário e quaisquer dados internos para controle de fluxo.
*   **Propósito:** Centralizar o estado é o que permite a depuração ("viagem no tempo"), a previsibilidade e, crucialmente, a capacidade de pausar e retomar a execução do grafo de forma confiável.

### 2. O Nó: A Unidade Atômica de Trabalho
*   **Conceito:** Um "Nó" não é um objeto complexo, mas uma **função pura e sem estado interno**. Cada nó tem uma única responsabilidade (ex: chamar a LLM, executar uma ferramenta, formatar uma saída).
*   **Contrato:** Um nó recebe o estado completo como entrada. Após realizar seu trabalho, ele retorna apenas um **objeto de atualização** (um "delta"), contendo somente as partes do estado que ele modificou. Ele nunca altera o estado diretamente.
*   **Propósito:** Este design garante que os nós sejam modulares, independentes, reutilizáveis e fáceis de testar isoladamente.

### 3. A Aresta: A Lógica do Fluxo de Controle
*   **Conceito:** A lógica que determina o caminho através do grafo é completamente separada da lógica de trabalho dos nós.
*   **Tipos de Aresta:**
    *   **Aresta Incondicional:** Um link direto e fixo. Define que após o Nó A, a execução *sempre* procederá para o Nó B. É o mecanismo para criar sequências lineares e ciclos de feedback.
    *   **Aresta Condicional:** Um ponto de decisão. É uma função que inspeciona o estado atual e retorna o nome do próximo nó a ser executado. É o mecanismo para criar ramificações, lógicas de `if/else` e, mais importante, as **condições de saída de um loop**.
*   **Propósito:** Desacoplar o fluxo do trabalho é o que torna o orquestrador flexível. Podemos reconfigurar completamente o comportamento de um agente apenas alterando as arestas, sem tocar na implementação de nenhum nó.

---

## Fase 2: Design da Arquitetura (O Blueprint)

Estes são os componentes estruturais que o desenvolvedor usará.

### 1. O Construtor de Grafos (A API do Desenvolvedor)
*   **Função:** Fornecer uma interface fluente e declarativa para que o usuário do framework possa definir a estrutura e a lógica de um grafo.
*   **Responsabilidades:**
    *   Registrar os nós (associando um nome a uma função de nó).
    *   Definir o ponto de entrada do grafo.
    *   Definir as arestas, tanto as incondicionais quanto as condicionais, conectando os nós registrados.
*   **Resultado Final:** O construtor não executa nada. Sua única função é produzir um **objeto de definição de grafo** – uma estrutura de dados estática, serializável e que representa o workflow completo.

### 2. O Motor de Execução (O Coração do Orquestrador)
*   **Função:** É o componente que de fato "roda" o grafo. Ele é agnóstico à lógica de negócio; sua única tarefa é seguir as instruções contidas na definição do grafo.
*   **O Loop de Execução:**
    1.  Recebe uma definição de grafo e um estado inicial.
    2.  Começa no nó de entrada definido.
    3.  **Ciclo:**
        a. Executa a função do nó atual, passando o estado atual.
        b. Recebe o objeto de atualização de estado e o mescla com o estado principal, criando uma nova versão do estado.
        c. Consulta a definição do grafo para encontrar a aresta que sai do nó atual.
        d. Se a aresta for condicional, executa sua função para determinar o próximo nó.
        e. Define o próximo nó como o nó atual e repete o ciclo.
    4.  O loop termina quando o próximo nó a ser executado é um nome reservado especial que significa "fim da execução" (ex: `__end__`).

---

## Fase 3: Incorporando a Interatividade (O Nó Humano)

Esta fase eleva o motor de um simples executor para uma plataforma de conversação.

### 1. O Nó de Interrupção
*   **Conceito:** Um tipo especial de nó que não executa lógica de negócio. Sua única função é sinalizar ao Motor de Execução para **pausar**.
*   **Funcionamento:** Quando o fluxo do grafo chega a este nó, o Motor interpreta isso como uma instrução para interromper o loop de execução.

### 2. O Ciclo de Vida "Pausar e Retomar"
*   **Mecanismo de Pausa:**
    1.  Ao encontrar um nó de interrupção, o Motor de Execução para imediatamente.
    2.  Ele persiste o estado atual completo, associando-o a um identificador de sessão único.
    3.  Retorna o controle à aplicação, indicando que está em um estado de espera.
*   **Mecanismo de Retomada:**
    1.  A aplicação, ao receber uma nova entrada externa (ex: uma mensagem do usuário), chama uma função de "retomada" no Motor.
    2.  A aplicação fornece o identificador da sessão e a nova entrada.
    3.  O Motor usa o identificador para carregar o estado que foi salvo, atualiza-o com a nova entrada e continua o loop de execução exatamente do ponto em que parou.

Este plano fornece uma base teórica completa para construir um orquestrador robusto, flexível e interativo, mantendo a simplicidade e o controle como princípios centrais.